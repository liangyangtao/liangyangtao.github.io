---
layout: post
title: Java线程模型
category: Java基础
date: 2016-02-07
---

标签： Java 多线程


<!-- more -->

## 简介

Java运行系统在很多方面依赖于线程，所有的类库设计都考虑到多线程。实际上，Java使用线程来使整个环境异步。这有利于通过防止CPU循环的浪费来减少无效部分。

为更好的理解多线程环境的优势可以将它与它的对照物相比较。

单线程系统的处理途径是使用一种叫作轮询的事件循环方法。在该模型中，单线程控制在一无限循环中运行，轮询一个事件序列来决定下一步做什么。

一旦轮询装置返回信号表明，已准备好读取网络文件，事件循环调度控制管理到适当的事件处理程序。直到事件处理程序返回，系统中没有其他事件发生。

这就浪费了CPU时间。这导致了程序的一部分独占了系统，阻止了其他事件的执行。

总的来说，单线程环境，当一个线程因为等待资源时阻塞（block，挂起执行），整个程序停止运行。

Java多线程的优点在于取消了主循环/轮询机制。一个线程可以暂停而不影响程序的其他部分。

例如，当一个线程从网络读取数据或等待用户输入时产生的空闲时间可以被利用到其他地方。多线程允许活的循环在每一帧间隙中沉睡一秒而不暂停整个系统。在Java程序中出现线程阻塞，仅有一个线程暂停，其他线程继续运行。

线程存在于好几种状态:线程可以正在运行（running）。只要获得CPU时间它就可以运行。运行的线程可以被挂起（suspend），并临时中断它的执行。一个挂起的线程可以被恢复（resume，允许它从停止的地方继续运行。
一个线程可以在等待资源时被阻塞（block）。在任何时候，线程可以终止（terminate），这立即中断了它的运行。一旦终止，线程不能被恢复。

### 线程优先级

Java给每个线程安排优先级以决定与其他线程比较时该如何对待该线程。线程优先级是详细说明线程间优先关系的整数。

作为绝对值，优先级是毫无意义的；当只有一个线程时，优先级高的线程并不比优先权低的线程运行的快。相反，线程的优先级是用来决定何时从一个运行的线程切换到另一个。这叫“上下文转换”(context switch)。

决定上下文转换发生的规则很简单：

线程可以自动放弃控制。在I/O未决定的情况下，睡眠或阻塞由明确的让步来完成。在这种假定下，所有其他的线程被检测，准备运行的最高优先级线程被授予CPU。

线程可以被高优先级的线程抢占。在这种情况下，低优先级线程不主动放弃，处理器只是被先占——无论它正在干什么——处理器被高优先级的线程占据。

基本上，一旦高优先级线程要运行，它就执行。这叫做有优先权的多任务处理。

当两个相同优先级的线程竞争CPU周期时，情形有一点复杂。

对于Windows98这样的操作系统，等优先级的线程是在循环模式下自动划分时间的。对于其他操作系统，例如Solaris 2.x，等优先级线程相对于它们的对等体自动放弃。如果不这样，其他的线程就不会运行。

警告：不同的操作系统下等优先级线程的上下文转换可能会产生错误。

### 同步性

因为多线程在你的程序中引入了一个异步行为，所以在你需要的时候必须有加强同步性的方法。

举例来说，如果你希望两个线程相互通信并共享一个复杂的数据结构，例如链表序列，你需要某些方法来确保它们没有相互冲突。也就是说，你必须防止一个线程写入数据而另一个线程正在读取链表中的数据。

为此目的，Java在进程间同步性的老模式基础上实行了另一种方法：管程（monitor）。管程是一种由C.A.R.Hoare首先定义的控制机制。

你可以把管程想象成一个仅控制一个线程的小盒子。一旦线程进入管程，所有线程必须等待直到该线程退出了管程。用这种方法，管程可以用来防止共享的资源被多个线程操纵。

很多多线程系统把管程作为程序必须明确的引用和操作的对象。Java提供一个清晰的解决方案。

没有“Monitor”类；相反，每个对象都拥有自己的隐式管程，当对象的同步方法被调用时管程自动载入。

一旦一个线程包含在一个同步方法中，没有其他线程可以调用相同对象的同步方法。这就使你可以编写非常清晰和简洁的多线程代码，因为同步支持是语言内置的。

### 消息传递

在你把程序分成若干线程后，你就要定义各线程之间的联系。用大多数其他语言规划时，你必须依赖于操作系统来确立线程间通信。

这样当然增加花费。然而，Java提供了多线程间谈话清洁的、低成本的途径——通过调用所有对象都有的预先确定的方法。

Java的消息传递系统允许一个线程进入一个对象的一个同步方法，然后在那里等待，直到其他线程明确通知它出来。

### Thread 类和Runnable 接口

Java的多线程系统建立于Thread类，它的方法，它的共伴接口Runnable基础上。Thread类封装了线程的执行。既然你不能直接引用运行着的线程的状态，你要通过它的代理处理它，于是Thread 实例产生了。

为创建一个新的线程，你的程序必须扩展Thread 或实现Runnable接口。

Thread类定义了好几种方法来帮助管理线程。

一些基本的方法如下：

<table>
<tr><th>方法</th><th>意义</th></tr>
<tr><td>getName</td><td>获得线程名称</td></tr>
<tr><td>getPriority</td><td>获得线程优先级</td></tr>
<tr><td>isAlive</td><td>判定线程是否仍在运行</td></tr>
<tr><td>join</td><td>等待一个线程终止</td></tr>
<tr><td>run</td><td>线程的入口点</td></tr>
<tr><td>sleep</td><td>在一段时间内挂起线程</td></tr>
<tr><td>start</td><td>通过调用运行方法来启动线程</td></tr>
</table>

## JSR133给Java内存模型定义以下一组happen-before规则

1 单线程规则：同一个线程中的每个操作都happens-before于出现在其后的任何一个操作。

2 对一个监视器的解锁操作happens-before于每一个后续对同一个监视器的加锁操作。

3 对volatile字段的写入操作happens-before于每一个后续的对同一个volatile字段的读操作。

4 Thread.start()的调用操作会happens-before于启动线程里面的操作。

5 一个线程中的所有操作都happens-before于其他线程成功返回在该线程上的join()调用后的所有操作。

6 一个对象构造函数的结束操作happens-before与该对象的finalizer的开始操作。

7 传递性规则：如果A操作happens-before于B操作，而B操作happens-before与C操作，那么A动作happens-before于C操作。


## 同步机制获取互斥锁

1 如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝。

2 类的每个实例都有自己的对象级别锁。当一个线程访问实例对象中的 synchronized 同步代码块或同步方法时，该线程便获取了该实例的对象级别锁，其他线程这时如果要访问 synchronized 同步代码块或同步方法，便需要阻塞等待，直到前面的线程从同步代码块或方法中退出，释放掉了该对象级别锁。

3 访问同一个类的不同实例对象中的同步代码块，不存在阻塞等待获取对象锁的问题，因为它们获取的是各自实例的对象级别锁，相互之间没有影响。

4 持有一个对象级别锁不会阻止该线程被交换出来，也不会阻塞其他线程访问同一示例对象中的非 synchronized 代码。当一个线程 A 持有一个对象级别锁（即进入了 synchronized 修饰的代码块或方法中）时，线程也有可能被交换出去，此时线程 B 有可能获取执行该对象中代码的时间，但它只能执行非同步代码（没有用 synchronized 修饰），当执行到同步代码时，便会被阻塞，此时可能线程规划器又让 A 线程运行，A 线程继续持有对象级别锁，当 A 线程退出同步代码时（即释放了对象级别锁），如果 B 线程此时再运行，便会获得该对象级别锁，从而执行 synchronized 中的代码。

5 持有对象级别锁的线程会让其他线程阻塞在所有的 synchronized 代码外。例如，在一个类中有三个synchronized 方法 a，b，c，当线程 A 正在执行一个实例对象 M 中的方法 a 时，它便获得了该对象级别锁，那么其他的线程在执行同一实例对象（即对象 M）中的代码时，便会在所有的 synchronized 方法处阻塞，即在方法 a，b，c 处都要被阻塞，等线程 A 释放掉对象级别锁时，其他的线程才可以去执行方法 a，b 或者 c 中的代码，从而获得该对象级别锁。

6 使用 synchronized（obj）同步语句块，可以获取指定对象上的对象级别锁。obj 为对象的引用，如果获取了 obj 对象上的对象级别锁，在并发访问 obj 对象时时，便会在其 synchronized 代码处阻塞等待，直到获取到该 obj对象的对象级别锁。当 obj 为 this 时，便是获取当前对象的对象级别锁。

7 类级别锁被特定类的所有示例共享，它用于控制对 static 成员变量以及 static 方法的并发访问。具体用法与对象级别锁相似。

8 互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized 关键字经过编译后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加 1，相应地，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁便被释放了。由于 synchronized 同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。

## 并行工作者模型

在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的CPU上。

如果在某个汽车厂里实现了并行工作者模型，每台车都会由一个工人来生产。工人们将拿到汽车的生产规格，并且从头到尾负责所有工作。

在Java应用系统中，并行工作者模型是最常见的并发模型（即使正在转变）。java.util.concurrent包中的许多并发实用工具都是设计用于这个模型的。你也可以在Java企业级（J2EE）应用服务器的设计中看到这个模型的踪迹。

